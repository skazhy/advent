#!/usr/bin/env python3

# Script to generate links to solved puzzles.

from itertools import repeat
from functools import reduce
import math
import json
import os.path
import sys
import re
import datetime

import subprocess


from puzzle_lookup import all_puzzles, run_git_cmd, staged_years, STAGED_FILE_CMD

### Fetching stars

THEME_SOURCE = "doc/themes.json"
PUZZLE_MD_PATH = "doc/PUZZLES.md"
THEME_MD_PATH = "doc/THEMES.md"


def run_utils_bb(*args):
    return subprocess.run(
        ["bb", "./scripts/utils.bb"] + list(args),
        capture_output=True,
        text=True,
    ).stdout.split("\n")[0]


def year_completion(year):
    fmt = ["", "&#9734;", "&#9734;&#9734;"]
    stars = run_utils_bb("stars", str(year))
    return {str(r[0]): fmt[r[1]] for r in eval(stars.replace(" ", ", "))}


### Markdown output


def md_link(url, title):
    return f"[{title}]({url})"


def md_rel_link(url, title):
    return md_link(f"../{url}", title)


def md_id_link(id_el, title):
    slug = re.sub(r"[^\w-]", "", id_el.lower().replace(" ", "-"))
    return md_link(f"#{slug}", title)


def md_table_row(*columns):
    return f"| {' | '.join(columns)} |\n"


def md_table_header(*columns):
    return f"{md_table_row(*columns)}| {' |'.join(repeat(' --- ', len(columns)))}|\n"


def md_header(title, level):
    return f"{''.join(repeat('#', level))} {title}\n\n"


def md_ul(content, indent=0):
    return f"{''.join(' ' for _ in range(indent))}- {content}\n"


def doc_footer():
    return f"_Note: this file was {md_rel_link('scripts/gen_docs.py', 'autogenerated')}, do not edit it directly._"


### Splitting existing MD file


def previously_solved_years(path):
    blocks = []
    if os.path.exists(path):
        block = []
        for row in [r.strip() for r in open(path, "r").readlines()]:
            if row == "":
                blocks.append(block)
                block = []
            else:
                block.append(row)
        years = {}
        i = 3  # Skip table of contents and main header
        while True:
            if len(blocks) > i + 1:
                if blocks[i + 1][0][0:3] == "Com":
                    stars = int(
                        re.match(
                            r"Completion: \d+% \((\d+) / 50 stars\)", blocks[i + 1][0]
                        )[1]
                    )
                    years[blocks[i][0][3:]] = {
                        "md": blocks[i + 1] + [""] + blocks[i + 2],
                        "stars": stars,
                    }
                    i += 3
                else:
                    years[blocks[i][0][3:]] = {"md": blocks[i + 1]}
                    i += 2
            else:
                break
        return years
    return {}


def title_lookup(year, day):
    return run_utils_bb("title", str(year), str(day))


def year_puzzle_tags(year):
    ret = {}
    for s in subprocess.run(
        ["git", "grep", "Tags", f"src/*/{year}/*"],
        capture_output=True,
        text=True,
    ).stdout.split("\n")[:-1]:
        (f, line, _, tags) = s.split(":")
        if int(line) < 5:
            ret[f] = [
                x.strip().replace('"', "").replace(")", "") for x in tags.split(",")
            ]
    return ret


def gen_completion_md(puzzles, staged_years):
    print("Regenerating completed puzzle doc...")
    existing_years = previously_solved_years(PUZZLE_MD_PATH)

    today = datetime.date.today()
    last_complete_year = today.year - 1
    if datetime.date.today().day > 24 and datetime.date.month == 12:
        last_complete_year = today.year

    with open(PUZZLE_MD_PATH, "w", encoding="utf-8") as doc:
        doc.write(md_header("Solved Advent of Code puzzles", 1))
        sorted_puzzles = sorted(puzzles.keys(), reverse=True)

        for year in sorted_puzzles:
            doc.write(md_ul(md_id_link(year, f"{year} puzzles")))
        doc.write("\n")

        total_stars = reduce(
            lambda acc, y: acc + y.get("stars", 0), existing_years.values(), 0
        )
        max_stars = (last_complete_year - 2015) * 50
        doc.write(
            f"Total completion rate in past years: {total_stars/max_stars:.0%} ({total_stars} / {max_stars} stars). "
        )
        doc.write(
            "Solutions marked as _slow_ complete both parts in more than 5 seconds.\n\n"
        )

        for year in sorted_puzzles:
            doc.write(md_header(year, 2))

            # Only refetch stars when there are staged puzzles for this year
            if year in staged_years:
                print(f"Fetching stars for {year}...")
                tags = year_puzzle_tags(year)
                stars = year_completion(year)
                if int(year) <= last_complete_year:
                    # Only count stars for puzzles available in the repo.
                    star_count = 0
                    for day, v in stars.items():
                        if v and puzzles[year].get(day):
                            star_count += len(v) / 7
                    star_count = math.floor(star_count)
                    doc.write(
                        f"Completion: {star_count/50:.0%} ({star_count} / 50 stars)\n\n"
                    )

                doc.write(md_table_header("Day", "Puzzle", "Solutions", "Completion"))
                for day in sorted(puzzles[year], key=int):
                    solutions = []
                    for lang in sorted(puzzles[year][day], key=lambda x: x):
                        sol = md_rel_link(puzzles[year][day][lang], lang)
                        if t := tags.get(puzzles[year][day][lang]):
                            sol = f"{sol} ({', '.join(t)})"
                        solutions.append(sol)
                    doc.write(
                        md_table_row(
                            day,
                            md_link(
                                f"https://adventofcode.com/{year}/day/{day}",
                                title_lookup(year, day),
                            ),
                            ", ".join(solutions),
                            stars[day],
                        )
                    )
            else:
                doc.write("\n".join(existing_years[year]["md"]))
                doc.write("\n")
            doc.write("\n")
        doc.write(doc_footer())


def write_theme_block(doc, theme, puzzles, level=2, lang=None):
    doc.write(md_header(theme["name"], level))
    _lang = lang or theme.get("lang")
    if theme.get("description"):
        doc.write(f"{theme['description']}\n\n")

    for y, d in theme.get("puzzles", []):
        if _lang:
            if url := puzzles[str(y)][str(d)].get(_lang):
                doc.write(md_ul(md_rel_link(url, f"{y}.{d}")))
        else:
            links = ", ".join(
                md_rel_link(url, lang) for lang, url in puzzles[str(y)][str(d)].items()
            )
            doc.write(md_ul(f'{y}.{d} "{title_lookup(y, d)}" in {links}'))
    if theme.get("puzzles"):
        doc.write("\n")

    for s in sorted(theme.get("sections", []), key=lambda s: s["name"]):
        write_theme_block(doc, s, puzzles, level=level + 1, lang=_lang)


def gen_theme_doc(puzzles):
    print("Regenerating puzzle theme doc...")
    themes = sorted(json.load(open(THEME_SOURCE, "r")), key=lambda t: t["name"])

    with open(THEME_MD_PATH, "w", encoding="utf-8") as doc:

        def write_toc(theme, indent):
            doc.write(md_ul(md_id_link(theme["name"], theme["name"]), indent=indent))
            for s in sorted(theme.get("sections", []), key=lambda s: s["name"]):
                write_toc(s, indent + 2)

        doc.write(md_header("Puzzle themes", 1))
        for theme in themes:
            write_toc(theme, 0)
        doc.write("\n")

        for theme in themes:
            write_theme_block(doc, theme, puzzles, lang=theme.get("lang"))
        doc.write(doc_footer())


if __name__ == "__main__":
    puzzles = all_puzzles()
    staged = staged_years()
    gen_all = False

    if "--all" in sys.argv[1:] or not os.path.exists(PUZZLE_MD_PATH):
        gen_all = True
        staged = set(puzzles.keys())

    if staged:
        gen_completion_md(puzzles, staged)

    if gen_all or run_git_cmd(STAGED_FILE_CMD + ["--", THEME_SOURCE]):
        gen_theme_doc(puzzles)
