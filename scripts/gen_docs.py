#!/usr/bin/env python3

# Script to generate links to solved puzzles.

from itertools import repeat
import urllib.request
import json
import os.path
import sys

import subprocess


from puzzle_lookup import all_puzzles, run_git_cmd, staged_years, STAGED_FILE_CMD

### Fetching stars


def parse_cal_row(row):
    if "calendar-verycomplete" in row:
        return "&#9734;&#9734;"
    elif "calendar-complete" in row:
        return "&#9734;"
    else:
        return ""


THEME_SOURCE = "doc/themes.json"
PUZZLE_MD_PATH = "doc/PUZZLES.md"
THEME_MD_PATH = "doc/THEMES.md"


def year_completion(year):
    span = '<span class="calendar-day">'
    req = urllib.request.Request(f"https://adventofcode.com/{year}")
    req.add_header("Cookie", str(open(".cookie").read().strip()))
    rows = [
        d for d in str(urllib.request.urlopen(req).read()).split("\\n") if span in d
    ]
    days = range(1, len(rows) + 1)
    if 'aria-label="Day 1' not in rows[0]:
        days = reversed(days)

    return {str(i): parse_cal_row(d) for i, d in zip(days, rows)}


### Markdown output


def md_link(url, title):
    return f"[{title}]({url})"


def md_rel_link(url, title):
    return md_link(f"../{url}", title)


def md_table_row(*columns):
    return f"| {' | '.join(columns)} |\n"


def md_table_header(*columns):
    return f"{md_table_row(*columns)}| {' |'.join(repeat(' --- ', len(columns)))}|\n"


def md_header(title, level):
    return f"{''.join(repeat('#', level))} {title}\n\n"


def md_ul(content):
    return f"- {content}\n"


def doc_footer():
    return f"_Note: this file was {md_rel_link('scripts/gen_docs.py', 'autogenerated')}, do not edit it directly._"


### Splitting existing MD file


def previously_solved_years(path):
    ret = []
    if os.path.exists(path):
        block = []
        for row in [r.strip() for r in open(path, "r").readlines()]:
            if row == "":
                ret.append(block)
                block = []
            else:
                block.append(row)
        years = {}
        i = 2  # Skip table of contents and main header
        while True:
            if len(ret) > i + 1:
                years[ret[i][0][3:]] = ret[i + 1]
                i += 2
            else:
                break
        return years
    return {}


def gen_completion_md(puzzles, staged_years):
    print("Regenerating completed puzzle doc...")
    existing_years = previously_solved_years(PUZZLE_MD_PATH)

    with open(PUZZLE_MD_PATH, "w", encoding="utf-8") as doc:
        doc.write(md_header("Solved Advent of Code puzzles", 1))
        sorted_puzzles = sorted(puzzles.keys(), reverse=True)

        for year in sorted_puzzles:
            doc.write(md_ul(md_link(f"#{year}", f"{year} puzzles")))
        doc.write("\n")

        for year in sorted_puzzles:
            doc.write(md_header(year, 2))

            # Only refetch stars when there are staged puzzles for this year
            if year in staged_years:
                print(f"Fetching stars for {year}...")
                stars = year_completion(year)
                doc.write(md_table_header("Day", "Solutions", "Completion"))
                for day in sorted(puzzles[year], key=int):
                    solutions = []
                    for lang in sorted(puzzles[year][day], key=lambda x: x):
                        solutions.append(md_rel_link(puzzles[year][day][lang], lang))
                    doc.write(md_table_row(day, ", ".join(solutions), stars[day]))
            else:
                doc.write("\n".join(existing_years[year]))
                doc.write("\n")
            doc.write("\n")
        doc.write(doc_footer())


def write_theme_block(doc, theme, puzzles, level=2):
    doc.write(md_header(theme["name"], level))
    if theme.get("description"):
        doc.write(f"{theme['description']}\n\n")

    for y, d in theme.get("puzzles", []):
        links = ", ".join(
            md_rel_link(url, lang) for lang, url in puzzles[str(y)][str(d)].items()
        )
        doc.write(md_ul(f"{y}.{d} in {links}"))
    if theme.get("puzzles"):
        doc.write("\n")

    for s in theme.get("sections", []):
        write_theme_block(doc, s, puzzles, level + 1)


def gen_theme_doc(puzzles):
    print("Regenerating puzzle theme doc...")
    themes = json.load(open(THEME_SOURCE, "r"))

    with open(THEME_MD_PATH, "w", encoding="utf-8") as doc:
        doc.write(md_header("Puzzle themes", 1))
        for theme in themes:
            write_theme_block(doc, theme, puzzles)
        doc.write(doc_footer())


if __name__ == "__main__":
    puzzles = all_puzzles()
    staged = staged_years()
    gen_all = False

    if "--all" in sys.argv[1:] or not os.path.exists(PUZZLE_MD_PATH):
        gen_all = True
        staged = set(puzzles.keys())

    if staged:
        gen_completion_md(puzzles, staged)

    if gen_all or run_git_cmd(STAGED_FILE_CMD + ["--", THEME_SOURCE]):
        gen_theme_doc(puzzles)
